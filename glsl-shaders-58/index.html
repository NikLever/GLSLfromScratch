<!-- Based on https://blog.theodo.com/2019/04/webgl-from-scratch/ -->
<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  <title>GLSL Shaders - Vanilla WebGL</title>
  <style>
    body { margin: 0; }
  </style>
</head>

<body>
  <script>
    let canvas, gl, program, position, glRect;

    init();

    function init() {
      setupWebGl();

      const vertices = [
        { position: [0, 0], color: [1.0, 1.0, 1.0] },
        { position: [0, window.innerHeight], color: [1.0, 0.0, 0.0] },
        { position: [window.innerWidth, window.innerHeight], color: [0.0, 0.0, 0.0] },
        { position: [window.innerWidth, 0], color: [0.0, 0.0, 0.0] }
      ];

      glRect = createSquareElement();

      program = setupProgram();

      set2fUniform(program, "screen_size", [window.innerWidth, window.innerHeight]);

      position = createAttribute(program, "position", vertices);
      const color = createAttribute(program, "color", vertices);

      onWindowResize();

      drawElement(glRect);

      window.addEventListener( 'resize', onWindowResize );
    }

    function setupWebGl() {
      canvas = document.createElement("canvas");
      //onWindowResize();
      document.body.appendChild(canvas);
      gl = canvas.getContext("webgl");
      if (gl == null) throw "WebGl not Supported";
      return gl;
    }

    function createSquareElement() {
      const indices = [0, 1, 2, 0, 2, 3];

      return createElement(indices);
    }

    function createElement(indices) {
      return {
        length: indices.length,
        indexBuffer: createIndicesBuffer(indices)
      };
    }

    function createIndicesBuffer(indices) {
      const buffer = gl.createBuffer();

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ELEMENT_ARRAY_BUFFER,
        new Uint16Array(indices),
        gl.STATIC_DRAW
      );

      return buffer;
    }

    function setupProgram() {
      const vertexSource = `
        uniform vec2 screen_size;
        attribute vec2 position;
        attribute vec3 color;

        varying vec3 blend_color;

        void main () {
          vec2 coord = 2.0 * (position / screen_size) - 1.0;
          gl_Position = vec4(coord.xy, 1, 1);

          blend_color = color;
        }
      `;
      const fragmentSource = `
        precision mediump float;

        varying vec3 blend_color;

        void main () {
          gl_FragColor = vec4(blend_color.rgb, 1); // Red
        }
      `;

      return compileShaders(vertexSource, fragmentSource);
    }

    function set2fUniform(program, uniformName, values) {
      const uniformLocation = gl.getUniformLocation(program, uniformName);
      gl.uniform2f(uniformLocation, ...values);
    }

    function createAttribute(program, name, vertices) {
      const values = vertices.map(vertex => vertex[name]);
      const size = values[0].length;

      const attribute = {
        values,
        buffer: createAttributeBuffer(program, name, size),
        refresh() {
          injectDataInto(this.buffer, this.values.flat());
        }
      };

      attribute.refresh();
      return attribute;
    }

    function createAttributeBuffer(program, attributeName, attributeSize) {
      const buffer = gl.createBuffer();
      const attributeLocation = gl.getAttribLocation(program, attributeName);

      gl.enableVertexAttribArray(attributeLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.vertexAttribPointer(
        attributeLocation,
        attributeSize, // Size
        gl.FLOAT, // Type
        false, // Normalize
        0, // Stride
        0 // Offset
      );

      return buffer;
    }

    function injectDataInto(buffer, data) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
    }

    function makeShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        gl.deleteShader(shader);
        console.warn(source);
        throw "Shader is Invalid";
      }
      return shader;
    }

    function makeProgram(vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.warn(gl.getProgramInfoLog(program));
        throw "Unable to link Program";
      }
      return program;
    }

    function compileShaders(vertexSource, fragmentSource) {
      const vertexShader = makeShader(gl.VERTEX_SHADER, vertexSource);
      const fragmentShader = makeShader(gl.FRAGMENT_SHADER, fragmentSource);
      const program = makeProgram(vertexShader, fragmentShader);
      gl.useProgram(program);
      return program;
    }

    function drawElement(element) {
      gl.drawElements(
        gl.TRIANGLES,
        element.length,
        gl.UNSIGNED_SHORT,
        element.indexBuffer
      );
    }

  
    function onWindowResize() {
      if (canvas){
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      if (program){
        set2fUniform( program, "screen_size", [window.innerWidth, window.innerHeight]);
      }

      if (position){
        position.values[0] = [0, 0];
        position.values[1] = [0, window.innerHeight];
        position.values[2] = [window.innerWidth, window.innerHeight];
        position.values[3] = [window.innerWidth, 0];
        position.refresh();
      }

      if (gl){
        gl.viewport(0, 0, window.innerWidth, window.innerHeight);
      }

      if (glRect) drawElement(glRect);
    }
  </script>

</body>

</html>
